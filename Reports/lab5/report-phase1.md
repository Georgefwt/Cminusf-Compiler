# Lab5 实验报告-阶段一

小组成员 姓名 学号

陈俊驰 PB18000051

余卓然 PB18000095

## 实验要求

请按照自己的理解，写明本次实验需要干什么


阅读`Mem2Reg`与`LoopSearch`两个优化Pass的说明及代码，能够描述优化的基本流程，在实验报告中完成思考题。通过阅读代码，了解并掌握如何开发基于LightIR的优化Pass。

## 思考题
### LoopSearch
1. 循环的入口如何确定？循环的入口的数量可能超过1嘛？

    根据PPT中独立于代码优化的部分可知，循环的入口是指进入循环的结点，根据定义可知，若要通过入口进入循环，该入口的一个直接前驱结点应为不属于该循环的结点集合。因此，可以通过找到一个直接前驱不在该循环中的结点，其为循环的入口。根据LoopSearch.cpp代码中find_loop_base部分可知，首先对于该循环结点集合中的每一个结点的每一个直接前驱进行遍历，若有一个结点的直接前驱不在该循环结点集合中，则该结点为入口。若没找到，有可能是由于循环嵌套从外到内寻找循环时，内层循环入口的前驱就是外层循环的入口，此时删除了外层循环的入口从而导致内层的循环成为独立的子图，不存在前驱不在循环结点集合中的结点。由此，可以通过遍历每一个存在reserved中已经找到了的循环的入口的每一个后继，如果该后继在所要找的循环结点集合中，那么说明该后继即为所求循环的入口。

    根据PPT中对于循环的定义“循环的结点集合有唯一的入口结点”，因此循环的入口数量不可能超过1。此外，通过find_loop_base返回值唯一，也可层面说明该结论。

2. 简述一下算法怎么解决循环嵌套的情况。

    对于一个代码的流图，其中循环的定义一部分为任意一个结点都有一个到达入口结点的非空路径，且该路径全部在循环的结点集合中，由此，根据图论的知识，一个代码中的循环就表示一个该代码流图的强连通子图。对于LoopSearch代码，其对于循环的搜索通过搜索该流图的强连通分量进行。首先对于完整的流图，搜索到的强连通分量为最外层的循环。然后，通过找到该循环对应的入口，并将其及其前驱后继关系从流图中删除，从而获得一系列子图。由于对于循环，我们均将条件判断的结点作为入口，删除条件判断的结点后，该强连通分量被破坏，该循环的action部分及其相连的结点集合将作为一个子图。通过代码中的while (strongly_connected_components(nodes, sccs))循环，再对所有子图进行搜索。如果存在循环的嵌套，那么内层循环就位于外层循环的action部分中，为对应强连通分量的一个强连通子图，此时外层的强连通分量被破坏，内层循环就暴露出来成为了一个新的强连通分量，将会被搜索强连通分量的函数找到，从而获得内层的循环。循环往复，逐层向内，删除base，查找内层循环对应的强连通分量，直到流图找不到任何的强连通分量，说明此时已经不存在循环了，停止对于循环的搜索。

    上述为对于循环的搜索，而对于入口，由于为了解决循环嵌套问题，将会对流图的结点进行删除，此时再找入口出现困难，故需要将被删除的base记录在reserved中，同时利用循环的结点集合set和已经被找到的入口集合reserved利用思考题1中的思路对入口进行搜索。最终确定入口和循环。

### Mem2reg
1. 请简述支配边界的概念。

    对于支配边界的严格定义如下，
(1)n支配m的一个前驱(q∈preds(m)且n∈Dom(q))
(2)n并不严格支配m
我们将相对于n具有这种性质的结点m的集合称为n的支配边界，记作DF(n)
其中，严格支配性为当且仅当a∈DOM(b)-{b}时，a严格支配b

    简单来说，如果结点 A 并不严格支配结点 B，而是支配结点 B 的立即前驱，那么结点 B 就在结点 A 的支配边界中。要特别注意以下情况，即当结点 A 不严格支配结点 B 且结点 A 就是结点 B 的立即前驱时，由于所有结点都支配它本身，于是结点 A 也支配它本身，这种情况下结点 B 也在结点 A 的支配边界里。从结点 A 的角度来看，可以把支配边界理解为结点 A 的支配关系终止的地方，也就是会有其他控制流出现的地方。


2. 请简述`phi`节点的概念，与其存在的意义。

    phi节点用于代表一个phi函数。在有多个前趋的程序块起始处，为当前过程中使用或定义的名字插入一个phi函数（定义虽如此，但在之后的优化过程中会利用支配树的信息来减少插入的phi函数），其中每一个前驱块有一个参数与之对应。在运行时，phi函数根据在当前结点之前执行的是哪一个前驱结点来得到相应的值。

    其存在的意义在于通过phi函数来确定前驱结点，进而获得相应的值，从而将通过alloc申请变量再进行存储和读取的值传递过程转换为直接利用中间变量的静态单赋值形式，进而对于时间与空间效率进行提升。

3. 请描述`Mem2Reg Pass`执行前后的`ir`的变化, 简述一下。

    相较于执行前的IR，执行了Mem2Reg Pass后的IR，删除了alloca代码，不再申请空间来存放值。消除了store和load，通过静态单赋值的形式，利用中间变量(类似%op5)来在各个基本块之间传递值。加入phi指令来对于当前正在执行的基本块的之前执行的是哪一个前驱进行判断，从而从响应的中间变量来获得相应的值。以优化后14基本块中'%op20 = phi i32 [ %op4, %label_entry ], [ %op3, %label10 ]'为例，如果是来自entry基本块，则应从%op4中取值，若来自10基本块，则应从%op3中取值。这与未优化前，在entry块中%op0存储%op4的值，或在10基本块中%op0存储%op1中的%op3的值，然后传递到14基本块被%op15使用效果完全一致。此外，对于函数所传递的参数也直接使用，而非存储到所申请的空间后再读取。

4. 在放置phi节点的时候，算法是如何利用支配树的信息的？

    Mem2Reg中放置phi结点，是通过generate_phi部分代码来实现的，这部分代码主要利用了支配树所计算的支配边界的信息。首先，算法找到所有全局名字及其基本块。对于每个全局名字x，算法首先对该名字申请一个work_list，初始化为该全局名字x被定义或赋值的基本块集合。对于work_list上的每个基本块b，算法会通过'dominators_->get_dominance_frontier(bb)'利用支配树找到该基本块b的支配边界，在支配边界的每个程序块d的起始处,若不存在对于该全局名字的phi，则初始化并放置phi结点，然后将相应的关系存入bb_has_var_phi中。在向d插入对于x的phi节点后，将基本块d加入到work_list并继续上述的循环操作，直到work_list中的每个基本块都被访问完成。

5. 算法是如何选择`value`(变量最新的值)来替换`load`指令的？（描述数据结构与维护方法）

    对于load指令的替换，在Mem2Reg.cpp中的re_name部分实现。通过阅读该部分第二个对于指令遍历的循环可发现，对于load指令，首先获得其所要存储值的左值l_val，然后从var_val_stack全局名字的栈对应l_val的栈顶取出对应的值，该值为变量最新的值，并所有使用该l_val的地方替换为从栈顶取出的值，然后将该load指令放入待删除指令集中。

    对于该变量最新的值的获取要通过栈var_val_stack的栈顶值来获取，该栈模拟了当前程序块最新定义的生命周期。具体维护方法如下：首先，对于每一个phi指令，将会将phi指令压入左值l_val的栈；然后，对于每一个load指令，将会将该指令的左值l_val的使用替换为栈顶的值，对于每一个store指令，将会将右值r_val压入左值l_val的栈，并将指令加入删除指令集；然后访问其每一个后继基本块并用本基本块的对应左值l_val栈顶填写其phi指令的参数；然后递归对于每个支配树中后继基本块进行re_name处理；在上述操作均结束后,对于块中每一条store和phi指令的左值l_val的最新定义的生命周期已经截止，将其从栈顶弹出，以恢复在该基本块的直接支配节点末尾处的当前静态单赋值形式名字集合。最后，还要对删除指令集中指令进行清除。

### 代码阅读总结

此次实验有什么收获

通过本次实验，对于大型代码阅读，遇到了不少困难，主要在于各部分代码之间的相互调用以及算法思想的理解上，通过相互讨论以后，有了很多的收获，主要了解了团队合作代码应当如何相互配合，减少因为接口导致的问题。还意识到了图论的知识与流图的知识本身是相通的，循环本身是强连通子图，可以通过强连通分量来找到循环，对于tarjan算法的学习，进一步加深了对于图这一数据结构的掌握，并加深了对于循环及入口定义的理解。通过对于Mem2Reg代码的阅读，学习并了解了如何从理论概念以及伪代码转换为实际的代码，代码风格规则统一，对于各种集合、栈、类的运用进一步提高了对于C++使用技艺。掌握了构造静态单赋值形式的简单方法--插入phi函数、重命名，并对支配树、支配边界等新概念有了初步的了解，一方面为接下来的实验打下了基础，另一方面，是对于课本机器无关知识的一个很好的补充。

### 实验反馈 （可选 不会评分）

对本次实验的建议

强烈建议在以后的实验中增加对于某些函数或变量名的全称或解释，我们再看phi的时候想了好久这是什么单词的缩写，结果是希腊字母（吐血）

### 组间交流 （可选）

本次实验和哪些组（记录组长学号）交流了哪一部分信息
